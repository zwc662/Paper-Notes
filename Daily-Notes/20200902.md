# 20200902
## Study paper [Type-and-Example-Directed Program Synthesis](https://dl.acm.org/doi/10.1145/2737924.2738007)

* Rather than just type information, the algorithm also uses concrete input-output examples to dramatically cut down the size of the search space
* For instance, let the inputs include a type signature, the definitions of any needed auxiliary functions, a synthesis goal specified by 
  * function name
  * I\O types
  * I\O examples
* Combining types and examples relies on the type structure of the PL to avoid ill-typed terms. Need to modify the typing rules so that they push examples toward sthe leaves of the typing derivation trees.
* Evaluate candidate terms early in the search process, thereby rpruning the search space combinatorially.
* Decompose the problem into independent sub-problems
* Invent an ML-like type system that incoporates I\O examples to constrain the set of legal program derivations.
* The type system is a non-deterministic specification of the synthesis problem where the goal is to find a term that has a valid typing derivation
  * Type system decomposes into a data structure (refinement tree) that concretize the parts of the search space that are shared among many candidate solutions
  * As well as an enumerative search that fills in the remaining holes.
* `Type refinement` turns the I\O examples into instantiations that match the respective types in the top-level structure
* `Guessing` fills in the body of the structure a term of which the type matches that of the output. Since no existing single type constructor satisfies the I/O examples, the synthesizer needs to enumearte or guess well-typed terms that involve vairables in beta-normal forms that cannot be reduced further
* `Match refinement` matches the possibilities with reality after exhausting all the options. Use a pattern match expression and leverage the existing terms to match each single I\O example.
  * For each example, a pattern is matched. Then this example is ruled out temporarily. Thereby, the I\O type instantiation set is refined.
  * After the first round of pattern matching, the second round of pattern matching starts nested in the matched patterns in the first round. Thus, a recursive function can be introduced.
  * `Enumeration`: choose a particular term shape; recursively generate its components
    * Generate an application: generate a function that produces the desired goal type; then generate a compatible argument
    * Generate a variable: choose any variable from the context of the appropriate type
  * Enforce two restrictiosn to ensure termination of evaluation:
    * syntactica structural recursion check enforces sturcturally decreasing arguments
    * positivity restriction on data types prevents recursive occurrences of a data type to the left of an arrow in the type of an argument to a constructor
  * To detect an inconsistent example set is to generate terms up to the size of the guaranteed program whose size is proportional to the size and amount of I\O examples. If any of these programs is SAT, then the example set is consistent. Otherwise, it is inconsistent. The size of the guaranteed program serves as an upper bound to the synthesis algorithm.
  * Guessing terms of certain type is raw E-term enumeration coupled with evaluation
    * Define a term generation function to enumerate E-term sets. Cache the results of guesing at a particular goal type so that enumeration will not be repeated. When context grows, create invocations of generation functions that maximize sharing of the context.
  * In `refinement tree`, there are two types of nodes: goal nodes contain goal types and represent places in the synthesis derivation where one can guess E term; refinement nodes represent valid I-refinement and produce branches for sub-problems.
    * Create a refinement tree from the initial context, goal type and provided examples
    * Guess beta-normal terms at each node
    * Bubble sucessful E-guesses and refined nullary constants upwards in the tree to construct a program that fits the goal
